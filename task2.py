# -*- coding: utf-8 -*-
"""task2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13q7o7N5QKvyEl7Ndem7MAxgKZI7T-3ux
"""

import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
from multiprocessing import Pool
from numba import njit,prange
import cProfile
import pstats
import cupy as cp

try:
    import secrets
    use_secrets = True
except ImportError:
    import np.random
    use_secrets = False
import matplotlib.animation as animation

def show_2_images(data1, data2,title=" ", title1="Module", title2="Phase", cmap1=None, cmap2=None):
    if isinstance(data1, np.ndarray) and isinstance(data2, np.ndarray) and data1.shape == data2.shape:
        plt.figure(figsize=(12, 6))
        plt.suptitle(title)
        plt.subplot(1, 2, 1)
        plt.title(title1)
        if data1.ndim == 3 and data1.shape[2] == 3:
            plt.imshow(data1)
        else:
            plt.imshow(data1, cmap=cmap1)
            plt.colorbar()

        plt.subplot(1, 2, 2)
        plt.title(title2)
        if data2.ndim == 3 and data2.shape[2] == 3:
            plt.imshow(data2)
        else:
            plt.imshow(data2, cmap=cmap2)
            plt.colorbar()

        plt.tight_layout()
        plt.show()

    else:
        print("Изображения должны быть numpy массивами одинакового размера.")

### IMAGE PREPARATION ###

image_path = "1.tif"
crypt = Image.open(image_path)

# Width must be 1030 height 1288
crypt = crypt.rotate(90, expand=True)
crypt_array = np.array(crypt)
#crypt_array = np.flipud(crypt_values)
print("Type:", crypt_array.dtype)  #uint16

# Check for correct reading
print("Min value:", np.min(crypt_array))
print("Max value:", np.max(crypt_array))

noise=34
# if value > noise, write value-nose, else write 0
crypt_values = np.where(crypt_array < noise, 0, crypt_array-noise)

#square root of intensity
crypt_values=np.sqrt(crypt_values)
crypt_values=crypt_values.astype(np.complex128)

# Check for correct noise removal
print("Min value:", np.min(crypt_values))
print("Max value:", np.max(crypt_values))

# Size check
Height, Width= crypt_values.shape
print("Width: ", Width, "Height: ", Height) #Width: 1030 Height: 1288

#######################################

### EXPERIMENTAL VALUES ###

Z=60*10*1000 #um
Lambda=632.8/1e3 #nm->um
K=2.*np.pi/Lambda

mask_width_um = 2.2 * 1000  # 2300 um
mask_height_um = 2.3 * 1000  # 2200 um

# detector size (в um)
det_width_um = 0.618 * 10 * 1000  # 6180 um
det_height_um = 0.7728 * 10 * 1000  # 7728 um

# grid step (um/px)
dx = det_width_um / Width
dy = det_height_um / Height

#######################################

### MASK CREATION ###

mask_width = int(mask_width_um /dx) #px
mask_height = int(mask_height_um /dy) #px

offset = int(100/dx) #px
Mask = np.zeros((Height, Width), dtype=np.float64)

center_x = Width // 2-offset
center_y = Height // 2

start_x = center_x - (mask_width // 2)
start_y = center_y - (mask_height // 2)

Mask[start_y:start_y + mask_height, start_x:start_x + mask_width] = 1.0
Antimask = 1.0 - Mask

#######################################

### VIRTUAL LENS ###

#Formula (9)
#crypt_values=crypt_values*Z/(2.*np.pi*K)
show_2_images(np.abs(crypt_values),np.angle(crypt_values))

x_grid = (np.arange(Width) - (Width // 2) - offset) * dx
y_grid = (np.arange(Height) - (Height // 2)) * dy
X, Y = np.meshgrid(x_grid, y_grid)
r_squared = X**2 + Y**2
r_squared=cp.asarray(r_squared)

Exp_ph=cp.exp(1j*K*r_squared/(2*Z))
Exp_ph_c=cp.exp(-1j*K*r_squared/(2*Z))

show_2_images(cp.asnumpy(cp.angle(Exp_ph_c)),cp.asnumpy(cp.angle(Exp_ph)))

################################

### RANDOM FIELD ###

@njit(parallel=True)
def generate_random_complex_field(width=Width, height=Height):
    rand_field = np.empty((height, width), dtype=np.complex128)
    for i in prange(height):
        for j in range(width):
            amplitude = np.random.randint(0, 3000)
            phase = np.random.random() * 2 * np.pi
            rand_field[i, j] = amplitude * np.exp(1j * phase)
    return rand_field

def generate_secret_random_complex_field(width=Width, height=Height):
    rand_field = np.empty((height, width), dtype=np.complex128)
    amplitudes = np.empty((height, width))
    phases = np.empty((height, width))
    for i in prange(height):
        for j in range(width):
            amplitudes[i, j] = secrets.randbelow(3000)
            phases[i, j] = secrets.randbits(64) / 2**64 * 2 * np.pi
    rand_field = amplitudes * np.exp(1j * phases)
    return rand_field
######################

### FFT&IFFT ###

def FT(data):
    data_gpu = cp.asarray(data)
    data_gpu = cp.fft.ifftshift(data_gpu)  # Перемещаем нулевую частоту в начало
    result_gpu = cp.fft.fft2(data_gpu)     # Стандартный FFT
    result_gpu = cp.fft.fftshift(result_gpu)  # Возвращаем нулевую частоту в центр
    return result_gpu

def IFT(data):
    data_gpu = cp.asarray(data)
    data_gpu = cp.fft.ifftshift(data_gpu)  # Перемещаем нулевую частоту в начало
    result_gpu = cp.fft.ifft2(data_gpu)     # Стандартный IFFT
    result_gpu = cp.fft.fftshift(result_gpu)  # Возвращаем нулевую частоту в центр
    return result_gpu

#######################################

### PROPAGATOR ###

def prop(field,backprop_flag):
  if backprop_flag==0:
    field_z=2*np.pi*K/(1j*Z)*cp.exp(1j*K*Z*(1+r_squared/(2*Z**2)))*FT(field)
  else:
    field_z=2*np.pi*K/(-1j*Z)*cp.exp(-1j*K*Z*(1+r_squared/(2*Z**2)))*IFT(field)
  return field_z

### PROJECTOR ###

def steps(X_inp, X_source):
  X_1=(cp.asarray(X_inp))
  #virtual lens
  X_2=X_1*Exp_ph

  #propagation (uncomment to use propagator)
  #X_3=prop(X_2,0)
  #X_3=cp.asarray(X_source)*X_3/cp.abs(X_3)

  X_3=FT(X_2)
  X_3=cp.asarray(X_source)*X_3/cp.abs(X_3)

  #backprop (uncomment to use propagator)
  #X_3=prop(X_3,1)

  #virtual lens (uncomment to use propagator)
  #X_out=X_3*Exp_ph_c

  X_out=IFT(X_3)*Exp_ph_c
  return cp.asnumpy(X_out)

def apply_mask2field(mask,field):
  mask=cp.asarray(mask)
  field=cp.asarray(field)
  mod=(cp.abs(field)*mask)
  phase=(cp.angle(field)*mask)
  return(cp.asnumpy(mod*np.exp(1j*phase)))

#######################################

### ER ###
def ER(N_iter: int, target, source):
    A = target  # 0th iteration --- random field distribution or the previous result
    for i in range(N_iter):
        D = steps(A, source)
        A=apply_mask2field(Mask,D)
    D_norm = cp.linalg.norm(D)
    A_norm = cp.linalg.norm(A)
    Error = cp.sqrt(D_norm**2 - A_norm**2) / D_norm
    return [A, Error]
##########

### HIO ###
def HIO(N_iter: int, beta: float, Target, Source):
    A = Target  # 0th iteration --- random field distribution or the previous result
    for i in range(N_iter):
        D = steps(A, Source)
        A = apply_mask2field(Mask,D) + apply_mask2field(Antimask, (A - beta * D))  # r-domain
    return A
###########

#from the task (30 HIO +10 ER)
def retrieving(img, real_img, beta,N):
    #real_img is the r-domain field for the HIO's 0th iteration, img --- "true" reciporal magnitude
    c_hio = HIO(N_iter=30, beta=beta, Target=real_img, Source=img)
    #got a c_hio field (in r-domain), now put it into 0th iteration for ER
    c_er,err = ER(N, target=c_hio, source=img)
    return [c_er,err]

############################################################
# This algorithm is taken from the work:                   #
# Artyukov, I.A., Vinogradov, A.V., Gorbunkov, M.V. et al. #
# Virtual Lens Method for Near-Field Phase Retrieval.      #
# Bull. Lebedev Phys. Inst. 50, 414–419 (2023).            #
# https://doi.org/10.3103/S1068335623100020                #
############################################################

def retr_block(inp,N=10):
    out1,err1 = retrieving(img=crypt_values,real_img=inp, beta=1.,N=N)
    out2,err2 = retrieving(img=crypt_values,real_img=out1,beta=0.7,N=N)
    out3,err3 = retrieving(img=crypt_values,real_img=out2,beta=0.4,N=N)
    out4,err4 = retrieving(img=crypt_values,real_img=out3,beta=0.1,N=N)
    return [out4,err4]

for i in range(100):
  if use_secrets:
      random_field = generate_secret_random_complex_field()
  else:
      random_field = generate_random_complex_field()
  field_1, error = retr_block(inp=random_field)
  for i in range (10):
    field_1, error = retr_block(inp=np.abs(field_1))
  field_1,error=retr_block(inp=field_1,N=200)
  show_2_images(data1=np.abs(field_1),data2=np.angle(field_1),title=f"Error:{error:.4f}")